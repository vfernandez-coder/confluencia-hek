<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <title>Confluencia HEK</title>

  <!-- Josefin Sans -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --c1:#AD7C68;
      --c2:#A95059;
      --c3:#864B5D;
      --c4:#4B4057;
      --c5:#234159;

      --bg: var(--c5);
      --card: rgba(75, 64, 87, 0.55);
      --border: rgba(173,124,104,0.25);
      --text: #f3ece9;
      --muted: rgba(243,236,233,0.82);
      --accent: var(--c2);

      /* Colores para los botones de archivo (degradado tipo tu muestra) */
      --fileA: #F2B19A;
      --fileB: #F26B7C;
    }

    body{
      font-family: "Josefin Sans", -apple-system, system-ui, sans-serif;
      font-size: 19px; /* +3 puntos (base) */
      margin:0;
      padding:18px;
      background: var(--bg);
      color: var(--text);
      display:flex;
      justify-content:center;
    }

    .main{ width:min(960px, 100%); }

    .header{
      text-align:center;
      margin: 6px 0 14px 0;
      padding: 14px 12px;
      border-radius: 16px;
      background: rgba(35,65,89,0.30);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .header h1{
      margin: 6px 0 0 0;
      font-size: clamp(22px, 3.4vw, 38px); /* m√°s grande */
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-weight: 700;
      line-height: 1.15;
    }

    .header p{
      margin: 10px 0 0 0;
      font-size: 17px; /* +3 */
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      margin-bottom: 12px;
      text-align: center;
      backdrop-filter: blur(6px);
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
    }

    button { font-size: 19px; } /* +3 */
    button{
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: var(--accent);
      color: #fff;
      font-family: inherit;
      font-weight: 700;
    }

    button.secondary{
      background: rgba(35,65,89,0.35);
      border: 1px solid rgba(255,255,255,0.14);
    }

    button:disabled{ opacity:0.45; }

    label{
      font-size: 17px; /* +3 vs 14 */
      color: var(--muted);
      font-weight: 600;
    }

    input[type="range"]{
      width: 200px;
      accent-color: var(--accent);
    }

    #status{
      font-size: 17px; /* +3 */
      color: var(--muted);
    }

    canvas, video{
      width: 100%;
      max-width: 860px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
    }

    .big{ font-size: 22px; font-weight: 800; letter-spacing: 0.02em; }
    .mono{ font-variant-numeric: tabular-nums; }
    .hint{ font-size: 16px; color: var(--muted); line-height: 1.35; } /* +3 */

    select{
      font-size: 18px; /* +3 */
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(35,65,89,0.35);
      color: var(--text);
      font-family: inherit;
      font-weight: 700;
    }

    /* ---- Botones bonitos para file inputs ---- */
    .fileInput{
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }

    .fileBtn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;

      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);

      color: #fff;
      font-size: 19px;   /* como Iniciar c√°mara */
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      font-family: inherit;
      background: linear-gradient(135deg, var(--fileA), var(--fileB));
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
    }

    .fileBtn:active{ transform: translateY(1px); }

    /* ---- Quesito ---- */
    .progressWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }

    .donut{ width: 48px; height: 48px; }

    .donut circle.track{
      stroke: rgba(243,236,233,0.20);
      stroke-width: 6;
      fill: none;
    }

    .donut circle.indicator{
      stroke: var(--accent);
      stroke-width: 6;
      fill: none;
      stroke-linecap: round;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
      transition: stroke-dashoffset 120ms linear;
    }

    .donutText{
      font-size: 16px; /* +3 */
      color: var(--muted);
      min-width: 52px;
      text-align:left;
      font-weight: 800;
    }

    .hidden{ display:none; }

    .footer{
      margin-top: 14px;
      text-align: center;
      padding: 14px 10px 6px 10px;
      color: rgba(243,236,233,0.88);
      font-size: 19px; /* +3 */
      letter-spacing: 0.02em;
    }

    .footer small{
      display:block;
      margin-top: 8px;
      color: rgba(243,236,233,0.70);
      font-size: 16px; /* +3 */
    }

    .footer em{
      font-style: normal;
      color: var(--c1);
      font-weight: 800;
    }

    .footer i{
      color: rgba(243,236,233,0.75);
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div class="main">

    <div class="header">
      <h1>AN√ÅLISIS DE CONFLUENCIA</h1>
      <p>Foto ‚Üí m√°scara ‚Üí porcentaje. Sin dramas.</p>
    </div>

    <div class="card">
      <div class="row">
        <button id="startCam" class="secondary">üì∑ Iniciar c√°mara (directo)</button>
        <button id="stopCam" class="secondary" disabled>‚õîÔ∏è Parar</button>
        <button id="snap" class="secondary" disabled>üéØ Capturar</button>
      </div>
      <p class="hint">
        Si la c√°mara en directo no funciona (a veces pasa en iOS en modo ‚Äúpantalla de inicio‚Äù),
        usa ‚ÄúHacer foto‚Äù.
      </p>
      <video id="video" playsinline muted></video>
    </div>

    <div class="card">
      <div class="row">
        <input id="filePick" class="fileInput" type="file" accept="image/*">
        <label for="filePick" class="fileBtn">üñºÔ∏è Seleccionar archivo</label>

        <input id="fileCam" class="fileInput" type="file" accept="image/*" capture="environment">
        <label for="fileCam" class="fileBtn">üì∏ Hacer foto</label>
      </div>
    </div>

    <div class="card">
      <div class="row" style="gap:14px;">
        <div class="big">Confluencia: <span id="pct" class="mono">‚Äî</span></div>

        <div class="progressWrap hidden" id="progressWrap" aria-hidden="true">
          <svg class="donut" viewBox="0 0 44 44">
            <circle class="track" cx="22" cy="22" r="16"></circle>
            <circle class="indicator" cx="22" cy="22" r="16"></circle>
          </svg>
          <div class="donutText mono" id="progressText">0%</div>
        </div>

        <div id="status">Cargando OpenCV‚Ä¶</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label>Modo:
          <select id="mode">
            <option value="edges">Edges (r√°pido)</option>
            <option value="texture">Texture (m√°s inclusivo)</option>
          </select>
        </label>

        <label>Sensibilidad <span id="sensVal" class="mono"></span>
          <input id="sens" type="range" min="0" max="100" value="55">
        </label>

        <label>Relleno <span id="fillVal" class="mono"></span>
          <input id="fill" type="range" min="0" max="12" value="5">
        </label>

        <label>Auto-c√≠rculo
          <select id="autoCircle">
            <option value="on" selected>ON</option>
            <option value="off">OFF</option>
          </select>
        </label>

        <button id="analyzeBtn" disabled>üî¨ Analizar confluencia</button>
        <button id="downloadMaskBtn" disabled>‚¨áÔ∏è Descargar m√°scara</button>
      </div>

      <p class="hint">
        Ajusta par√°metros y pulsa <b>Analizar confluencia</b>. No se analiza autom√°ticamente.
        Si tu imagen no tiene campo circular/borde negro, pon Auto-c√≠rculo = OFF.
      </p>

      <canvas id="canvas"></canvas>
    </div>

    <div class="footer">
      Ya no es un problema que tengas un ojo terrible calculando confluencias.
      <small><em>Cultivos celulares para todos</em> ¬∑ Medir la confluencia ahora es f√°cil y gratis </small>
      <small><i>Hecho por Virginia Fern√°ndez con (mucha) ayuda de ChatGPT</i></small>
    </div>

  </div>

  <!-- OpenCV.js (oficial desde docs.opencv.org) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const pctEl = document.getElementById('pct');
    const statusEl = document.getElementById('status');

    const startCamBtn = document.getElementById('startCam');
    const stopCamBtn = document.getElementById('stopCam');
    const snapBtn = document.getElementById('snap');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadMaskBtn = document.getElementById('downloadMaskBtn');

    const filePick = document.getElementById('filePick');
    const fileCam = document.getElementById('fileCam');

    const sens = document.getElementById('sens');
    const fill = document.getElementById('fill');
    const sensVal = document.getElementById('sensVal');
    const fillVal = document.getElementById('fillVal');
    const mode = document.getElementById('mode');
    const autoCircle = document.getElementById('autoCircle');

    // Quesito
    const progressWrap = document.getElementById('progressWrap');
    const progressText = document.getElementById('progressText');
    const indicator = document.querySelector('.donut circle.indicator');
    const R = 16;
    const CIRC = 2 * Math.PI * R;
    indicator.style.strokeDasharray = `${CIRC} ${CIRC}`;
    indicator.style.strokeDashoffset = `${CIRC}`;

    let stream = null;
    let cvReady = false;
    let lastImage = null;       // ImageData
    let isAnalyzing = false;
    let lastMaskDataURL = null; // PNG para descargar

    function setStatus(msg) { statusEl.textContent = msg; }

    function updateUI() {
      sensVal.textContent = sens.value;
      fillVal.textContent = fill.value;
    }

    function updateButtons() {
      analyzeBtn.disabled = !(cvReady && lastImage) || isAnalyzing;
      downloadMaskBtn.disabled = !lastMaskDataURL || isAnalyzing;
    }

    function showProgress(show) {
      progressWrap.classList.toggle('hidden', !show);
      progressWrap.setAttribute('aria-hidden', show ? 'false' : 'true');
    }

    function setProgress(pct) {
      const p = Math.max(0, Math.min(100, pct));
      const offset = CIRC - (p / 100) * CIRC;
      indicator.style.strokeDashoffset = `${offset}`;
      progressText.textContent = `${Math.round(p)}%`;
    }

    function nextFrame() {
      return new Promise(resolve => requestAnimationFrame(() => resolve()));
    }

    updateUI();
    updateButtons();
    showProgress(false);

    // OpenCV init (FIX iOS) ‚Äî nunca analiza autom√°ticamente
    let hooked = false;
    const cvWait = setInterval(() => {
      if (typeof cv !== 'undefined') {
        if (!hooked) {
          hooked = true;
          cv['onRuntimeInitialized'] = () => {
            cvReady = true;
            setStatus('OpenCV listo ‚úÖ Carga una imagen y pulsa "Analizar confluencia".');
            updateButtons();
          };
        }
        if (cv.Mat) {
          cvReady = true;
          setStatus('OpenCV listo ‚úÖ Carga una imagen y pulsa "Analizar confluencia".');
          updateButtons();
          clearInterval(cvWait);
        }
      }
    }, 50);

    setTimeout(() => {
      if (!cvReady) setStatus('OpenCV no ha cargado (prueba recargar / otra red).');
    }, 12000);

    async function startCamera() {
      try {
        setStatus('Pidiendo permisos de c√°mara‚Ä¶');
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        snapBtn.disabled = false;
        stopCamBtn.disabled = false;
        setStatus('C√°mara activa ‚úÖ Captura una imagen y luego pulsa "Analizar confluencia".');
      } catch (e) {
        console.error(e);
        setStatus('No se pudo abrir la c√°mara. Prueba ‚ÄúHacer foto‚Äù.');
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      snapBtn.disabled = true;
      stopCamBtn.disabled = true;
      setStatus('C√°mara parada.');
    }

    function drawToCanvasFromVideo() {
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return;
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(video, 0, 0, w, h);
      lastImage = ctx.getImageData(0, 0, w, h);
    }

    function drawToCanvasFromImage(img) {
      const w = img.width;
      const h = img.height;
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);
      lastImage = ctx.getImageData(0, 0, w, h);
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function buildMaskPNG(maskMat8U) {
      // PNG con fondo transparente y m√°scara roja
      const w = maskMat8U.cols;
      const h = maskMat8U.rows;
      const off = document.createElement('canvas');
      off.width = w;
      off.height = h;
      const ctx = off.getContext('2d');

      const img = ctx.createImageData(w, h);
      const dst = img.data;
      const src = maskMat8U.data; // Uint8Array

      // Rojo con alpha 180
      for (let i = 0, p = 0; i < src.length; i++, p += 4) {
        if (src[i]) {
          dst[p] = 255;
          dst[p+1] = 0;
          dst[p+2] = 0;
          dst[p+3] = 180;
        } else {
          dst[p] = 0;
          dst[p+1] = 0;
          dst[p+2] = 0;
          dst[p+3] = 0;
        }
      }

      ctx.putImageData(img, 0, 0);
      return off.toDataURL('image/png');
    }

    function downloadDataURL(dataURL, filename) {
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    async function analyze() {
      if (!cvReady) { setStatus('OpenCV a√∫n cargando‚Ä¶'); return; }
      if (!lastImage) { setStatus('Carga una imagen o captura una foto.'); return; }
      if (isAnalyzing) return;

      // invalidar m√°scara anterior
      lastMaskDataURL = null;
      isAnalyzing = true;
      const oldBtn = analyzeBtn.textContent;
      analyzeBtn.textContent = 'Analizando‚Ä¶';
      updateButtons();

      showProgress(true);
      setProgress(0);
      setStatus('Analizando‚Ä¶');
      await nextFrame();

      try {
        const sens01 = parseInt(sens.value, 10) / 100;
        const fillPx = parseInt(fill.value, 10);
        const useAutoCircle = (autoCircle.value === 'on');
        const whichMode = mode.value;

        setProgress(8);  await nextFrame();

        // Downscale para m√≥vil
        const MAX_SIDE = 1100;
        let src = cv.matFromImageData(lastImage); // RGBA
        const w0 = src.cols, h0 = src.rows;
        const scale = Math.min(1, MAX_SIDE / Math.max(w0, h0));
        if (scale < 1) {
          let resized = new cv.Mat();
          cv.resize(src, resized, new cv.Size(Math.round(w0*scale), Math.round(h0*scale)), 0, 0, cv.INTER_AREA);
          src.delete();
          src = resized;
        }

        setProgress(20); await nextFrame();

        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        setProgress(30); await nextFrame();

        // ROI
        let fieldMask;
        if (useAutoCircle) {
          fieldMask = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8U);

          let cx = Math.floor(gray.cols/2), cy = Math.floor(gray.rows/2);
          let radius = Math.floor(Math.min(gray.cols, gray.rows)*0.48);

          let blur = new cv.Mat();
          cv.medianBlur(gray, blur, 5);

          let circles = new cv.Mat();
          cv.HoughCircles(
            blur, circles, cv.HOUGH_GRADIENT,
            1,
            gray.rows/4,
            120,
            25,
            Math.floor(Math.min(gray.cols, gray.rows)*0.30),
            Math.floor(Math.min(gray.cols, gray.rows)*0.52)
          );

          if (circles.cols > 0) {
            let best = 0;
            for (let i=0; i<circles.cols; i++) {
              const r = circles.data32F[i*3+2];
              if (r > circles.data32F[best*3+2]) best = i;
            }
            cx = Math.round(circles.data32F[best*3]);
            cy = Math.round(circles.data32F[best*3+1]);
            radius = Math.round(circles.data32F[best*3+2] * 0.98);
          }

          blur.delete(); circles.delete();
          cv.circle(fieldMask, new cv.Point(cx, cy), radius, new cv.Scalar(255), -1);
        } else {
          fieldMask = new cv.Mat(gray.rows, gray.cols, cv.CV_8U, new cv.Scalar(255));
        }

        setProgress(45); await nextFrame();

        // Segmentaci√≥n
        let cellMask = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8U);

        if (whichMode === 'edges') {
          let blur2 = new cv.Mat();
          cv.GaussianBlur(gray, blur2, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

          let edges = new cv.Mat();
          const t1 = clamp(20 + (1 - sens01) * 60, 10, 90);
          const t2 = clamp(t1 * 2.5, 40, 220);
          cv.Canny(blur2, edges, t1, t2);

          edges.copyTo(cellMask);
          blur2.delete(); edges.delete();
        } else {
          let blur2 = new cv.Mat();
          cv.GaussianBlur(gray, blur2, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

          let lap16 = new cv.Mat();
          cv.Laplacian(blur2, lap16, cv.CV_16S, 3, 1, 0, cv.BORDER_DEFAULT);

          let abs8 = new cv.Mat();
          cv.convertScaleAbs(lap16, abs8);

          const thr = clamp(10 + (1 - sens01) * 40, 5, 60);
          cv.threshold(abs8, cellMask, thr, 255, cv.THRESH_BINARY);

          blur2.delete(); lap16.delete(); abs8.delete();
        }

        setProgress(70); await nextFrame();

        if (fillPx > 0) {
          const k = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(fillPx*2+1, fillPx*2+1));
          cv.morphologyEx(cellMask, cellMask, cv.MORPH_CLOSE, k);
          cv.dilate(cellMask, cellMask, k);
          k.delete();
        }

        setProgress(82); await nextFrame();

        let cellInField = new cv.Mat();
        cv.bitwise_and(cellMask, fieldMask, cellInField);

        // Confluencia
        const fieldCount = cv.countNonZero(fieldMask);
        const cellCount  = cv.countNonZero(cellInField);
        const confluence = (fieldCount > 0) ? (100.0 * cellCount / fieldCount) : 0;
        pctEl.textContent = confluence.toFixed(1) + '%';

        setProgress(90); await nextFrame();

        // Overlay
        let overlay = src.clone();
        let red = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(255, 0, 0, 90));
        let redMasked = new cv.Mat.zeros(src.rows, src.cols, src.type());
        red.copyTo(redMasked, cellInField);
        cv.addWeighted(overlay, 1.0, redMasked, 1.0, 0.0, overlay);

        if (useAutoCircle) {
          let outside = new cv.Mat();
          cv.bitwise_not(fieldMask, outside);
          let dim = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(0,0,0,140));
          let dimMasked = new cv.Mat.zeros(src.rows, src.cols, src.type());
          dim.copyTo(dimMasked, outside);
          cv.addWeighted(overlay, 1.0, dimMasked, 1.0, 0.0, overlay);
          outside.delete(); dim.delete(); dimMasked.delete();
        }

        cv.imshow(canvas, overlay);

        // Genera PNG de m√°scara (transparente + rojo) para descargar
        lastMaskDataURL = buildMaskPNG(cellInField);

        setProgress(100); await nextFrame();

        // Limpieza
        src.delete(); gray.delete(); fieldMask.delete();
        cellMask.delete(); cellInField.delete();
        overlay.delete(); red.delete(); redMasked.delete();

        setStatus('Listo ‚úÖ (si la m√°scara no encaja, ajusta par√°metros y vuelve a analizar)');
        setTimeout(() => { showProgress(false); }, 700);

      } catch (e) {
        console.error(e);
        setStatus('Error analizando (mira consola / prueba otra foto).');
        showProgress(false);
        lastMaskDataURL = null;
      } finally {
        isAnalyzing = false;
        analyzeBtn.textContent = oldBtn || 'üî¨ Analizar confluencia';
        updateButtons();
      }
    }

    // Eventos (NUNCA an√°lisis autom√°tico)
    startCamBtn.addEventListener('click', startCamera);
    stopCamBtn.addEventListener('click', stopCamera);

    snapBtn.addEventListener('click', () => {
      drawToCanvasFromVideo();
      setStatus('Captura hecha ‚úÖ Ajusta par√°metros y pulsa "Analizar confluencia".');
      showProgress(false);
      setProgress(0);
      lastMaskDataURL = null;
      updateButtons();
    });

    analyzeBtn.addEventListener('click', () => analyze());

    downloadMaskBtn.addEventListener('click', () => {
      if (!lastMaskDataURL) return;
      const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      downloadDataURL(lastMaskDataURL, `mascara_${ts}.png`);
    });

    function handleFile(file) {
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        drawToCanvasFromImage(img);
        setStatus('Imagen cargada ‚úÖ Ajusta par√°metros y pulsa "Analizar confluencia".');
        showProgress(false);
        setProgress(0);
        lastMaskDataURL = null;
        updateButtons();
      };
      img.src = URL.createObjectURL(file);
    }

    filePick.addEventListener('change', (e) => handleFile(e.target.files[0]));
    fileCam.addEventListener('change',  (e) => handleFile(e.target.files[0]));

    ;[sens, fill, mode, autoCircle].forEach(el => {
      el.addEventListener('input', () => { updateUI(); });
      el.addEventListener('change', () => { updateUI(); });
    });

    updateUI();
  </script>
</body>
</html>
