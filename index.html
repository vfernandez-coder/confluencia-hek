<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">

  <title>Cell culture for dummies</title>

  <!-- Josefin Sans -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Josefin+Sans:wght@300;400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --c1:#AD7C68;
      --c2:#A95059;
      --c3:#864B5D;
      --c4:#4B4057;
      --c5:#234159;

      --bg: var(--c5);
      --card: rgba(75, 64, 87, 0.55);
      --border: rgba(173,124,104,0.25);
      --text: #f3ece9;
      --muted: rgba(243,236,233,0.82);
      --accent: var(--c2);

      /* Colores botones de archivo (degradado) */
      --fileA: #F2B19A;
      --fileB: #F26B7C;
    }

    body{
      font-family: "Josefin Sans", -apple-system, system-ui, sans-serif;
      font-size: 19px;
      margin:0;
      padding:18px;
      background: var(--bg);
      color: var(--text);
      display:flex;
      justify-content:center;
    }

    .main{ width:min(960px, 100%); }

    .header{
      text-align:center;
      margin: 6px 0 14px 0;
      padding: 14px 12px;
      border-radius: 16px;
      background: rgba(35,65,89,0.30);
      border: 1px solid rgba(255,255,255,0.10);
    }

    .langbar{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    .langbtn{
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(35,65,89,0.35);
      color: var(--text);
      font-family: inherit;
      font-weight: 800;
      font-size: 17px;
      cursor: pointer;
      user-select:none;
    }

    .langbtn.active{
      background: rgba(169,80,89,0.35);
      border-color: rgba(255,255,255,0.20);
    }

    .header h1{
      margin: 6px 0 0 0;
      font-size: clamp(22px, 3.4vw, 38px);
      letter-spacing: 0.10em;
      text-transform: uppercase;
      font-weight: 700;
      line-height: 1.15;
    }

    .header p{
      margin: 10px 0 0 0;
      font-size: 17px;
      color: var(--muted);
      letter-spacing: 0.02em;
    }

    .card{
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      margin-bottom: 12px;
      text-align: center;
      backdrop-filter: blur(6px);
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
    }

    button { font-size: 19px; }
    button{
      padding:10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: var(--accent);
      color: #fff;
      font-family: inherit;
      font-weight: 700;
      cursor: pointer;
    }

    button.secondary{
      background: rgba(35,65,89,0.35);
      border: 1px solid rgba(255,255,255,0.14);
    }

    button:disabled{ opacity:0.45; cursor: default; }

    label{
      font-size: 17px;
      color: var(--muted);
      font-weight: 600;
    }

    input[type="range"]{
      width: 200px;
      accent-color: var(--accent);
    }

    #status{
      font-size: 17px;
      color: var(--muted);
    }

    canvas, video{
      width: 100%;
      max-width: 860px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.10);
    }

    .big{ font-size: 22px; font-weight: 800; letter-spacing: 0.02em; }
    .mono{ font-variant-numeric: tabular-nums; }
    .hint{ font-size: 16px; color: var(--muted); line-height: 1.35; }

    select{
      font-size: 18px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(35,65,89,0.35);
      color: var(--text);
      font-family: inherit;
      font-weight: 700;
    }

    /* File inputs bonitos */
    .fileInput{
      position: absolute;
      left: -9999px;
      width: 1px;
      height: 1px;
      opacity: 0;
    }

    .fileBtn{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;

      padding: 10px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.14);

      color: #fff;
      font-size: 19px;
      font-weight: 800;
      cursor: pointer;
      user-select: none;
      font-family: inherit;
      background: linear-gradient(135deg, var(--fileA), var(--fileB));
      box-shadow: 0 8px 18px rgba(0,0,0,0.18);
    }
    .fileBtn:active{ transform: translateY(1px); }

    /* Quesito */
    .progressWrap{
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
    }

    .donut{ width: 48px; height: 48px; }

    .donut circle.track{
      stroke: rgba(243,236,233,0.20);
      stroke-width: 6;
      fill: none;
    }

    .donut circle.indicator{
      stroke: var(--accent);
      stroke-width: 6;
      fill: none;
      stroke-linecap: round;
      transform: rotate(-90deg);
      transform-origin: 50% 50%;
      transition: stroke-dashoffset 120ms linear;
    }

    .donutText{
      font-size: 16px;
      color: var(--muted);
      min-width: 52px;
      text-align:left;
      font-weight: 800;
    }

    .hidden{ display:none; }

    .footer{
      margin-top: 14px;
      text-align: center;
      padding: 14px 10px 6px 10px;
      color: rgba(243,236,233,0.88);
      font-size: 19px;
      letter-spacing: 0.02em;
    }

    .footer small{
      display:block;
      margin-top: 8px;
      color: rgba(243,236,233,0.70);
      font-size: 16px;
    }

    .footer em{
      font-style: normal;
      color: var(--c1);
      font-weight: 800;
    }

    .footer i{
      color: rgba(243,236,233,0.75);
      font-weight: 600;
    }
  </style>
</head>

<body>
  <div class="main">

    <div class="header">
      <div class="langbar">
        <button id="btnEN" class="langbtn" type="button">üá¨üáß English</button>
        <button id="btnES" class="langbtn" type="button">üá™üá∏ Espa√±ol</button>
      </div>

      <h1 id="hdrTitle">AN√ÅLISIS DE CONFLUENCIA</h1>
      <p id="hdrTagline">Foto ‚Üí m√°scara ‚Üí porcentaje. Sin dramas.</p>
    </div>

    <div class="card">
      <div class="row">
        <button id="startCam" class="secondary" type="button">üì∑ Iniciar c√°mara (directo)</button>
        <button id="stopCam" class="secondary" type="button" disabled>‚õîÔ∏è Parar</button>
        <button id="snap" class="secondary" type="button" disabled>üéØ Capturar</button>
      </div>
      <p class="hint" id="hintCam">
        Si la c√°mara en directo no funciona (a veces pasa en iOS en modo ‚Äúpantalla de inicio‚Äù),
        usa ‚ÄúHacer foto‚Äù aqu√≠ abajo.
      </p>
      <video id="video" playsinline muted></video>
    </div>

    <div class="card">
      <div class="row">
        <input id="filePick" class="fileInput" type="file" accept="image/*">
        <label for="filePick" id="btnPick" class="fileBtn">üñºÔ∏è Seleccionar archivo</label>

        <input id="fileCam" class="fileInput" type="file" accept="image/*" capture="environment">
        <label for="fileCam" id="btnPhoto" class="fileBtn">üì∏ Hacer foto</label>
      </div>
    </div>

    <div class="card">
      <div class="row" style="gap:14px;">
        <div class="big"><span id="lblConfluence">Confluencia</span>: <span id="pct" class="mono">‚Äî</span></div>

        <div class="progressWrap hidden" id="progressWrap" aria-hidden="true">
          <svg class="donut" viewBox="0 0 44 44">
            <circle class="track" cx="22" cy="22" r="16"></circle>
            <circle class="indicator" cx="22" cy="22" r="16"></circle>
          </svg>
          <div class="donutText mono" id="progressText">0%</div>
        </div>

        <div id="status">Cargando OpenCV‚Ä¶</div>
      </div>

      <div class="row" style="margin-top:10px;">
        <label id="lblModeWrap"><span id="lblMode">Modo</span>:
          <select id="mode">
            <option value="edges" id="optEdges">Edges (r√°pido)</option>
            <option value="texture" id="optTexture">Texture (m√°s inclusivo)</option>
          </select>
        </label>

        <label><span id="lblSens">Sensibilidad</span> <span id="sensVal" class="mono"></span>
          <input id="sens" type="range" min="0" max="100" value="55">
        </label>

        <label><span id="lblFill">Relleno</span> <span id="fillVal" class="mono"></span>
          <input id="fill" type="range" min="0" max="12" value="5">
        </label>

        <label id="lblAutoWrap"><span id="lblAuto">Auto-c√≠rculo</span>
          <select id="autoCircle">
            <option value="on" id="optAutoOn" selected>ON</option>
            <option value="off" id="optAutoOff">OFF</option>
          </select>
        </label>

        <button id="analyzeBtn" type="button" disabled>üî¨ Analizar confluencia</button>
        <button id="downloadMaskBtn" type="button" disabled>‚¨áÔ∏è Descargar m√°scara</button>
      </div>

      <p class="hint" id="hintAnalyze">
        Ajusta par√°metros y pulsa <b>Analizar confluencia</b>. No se analiza autom√°ticamente.
        Si tu imagen no tiene campo circular/borde negro, pon Auto-c√≠rculo = OFF.
      </p>

      <canvas id="canvas"></canvas>
    </div>

    <div class="footer">
      <span id="footerLine">Ya no es un problema que tengas un ojo terrible calculando confluencias.</span>
      <span id="footerSub">Confluencia hecha f√°cil.</span></small>
      <small><i id="footerMade">Hecho por Virginia Fern√°ndez con (mucha) ayuda de ChatGPT</i></small>
    </div>

  </div>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <script>
    // ---------- i18n ----------
    const I18N = {
      es: {
        hdrTitle: "AN√ÅLISIS DE CONFLUENCIA",
        hdrTagline: "Foto ‚Üí m√°scara ‚Üí porcentaje. Sin dramas.",

        startCam: "üì∑ Iniciar c√°mara (directo)",
        stopCam: "‚õîÔ∏è Parar",
        snap: "üéØ Capturar",

        hintCam: "Si la c√°mara en directo no funciona (a veces pasa en iOS en modo ‚Äúpantalla de inicio‚Äù), usa ‚ÄúHacer foto‚Äù aqu√≠ abajo.",
        btnPick: "üñºÔ∏è Seleccionar archivo",
        btnPhoto: "üì∏ Hacer foto",

        lblConfluence: "Confluencia",
        statusOpenCVLoading: "Cargando OpenCV‚Ä¶",
        statusOpenCVReady: "OpenCV listo ‚úÖ Carga una imagen y pulsa \"Analizar confluencia\".",
        statusOpenCVNever: "OpenCV no ha cargado (prueba recargar / otra red).",
        statusNeedImage: "Carga una imagen o captura una foto.",
        statusCameraPerm: "Pidiendo permisos de c√°mara‚Ä¶",
        statusCameraActive: "C√°mara activa ‚úÖ Captura una imagen y luego pulsa \"Analizar confluencia\".",
        statusCameraFail: "No se pudo abrir la c√°mara. Prueba ‚ÄúHacer foto‚Äù.",
        statusCameraStopped: "C√°mara parada.",
        statusCaptureDone: "Captura hecha ‚úÖ Ajusta par√°metros y pulsa \"Analizar confluencia\".",
        statusImageLoaded: "Imagen cargada ‚úÖ Ajusta par√°metros y pulsa \"Analizar confluencia\".",
        statusAnalyzing: "Analizando‚Ä¶",
        statusDone: "Listo ‚úÖ (si la m√°scara no encaja, ajusta par√°metros y vuelve a analizar)",
        statusError: "Error analizando (mira consola / prueba otra foto).",

        lblMode: "Modo",
        optEdges: "Edges (r√°pido)",
        optTexture: "Texture (m√°s inclusivo)",
        lblSens: "Sensibilidad",
        lblFill: "Relleno",
        lblAuto: "Auto-c√≠rculo",

        analyzeBtn: "üî¨ Analizar confluencia",
        analyzingBtn: "Analizando‚Ä¶",
        downloadMaskBtn: "‚¨áÔ∏è Descargar m√°scara",

        hintAnalyze: "Ajusta par√°metros y pulsa <b>Analizar confluencia</b>. No se analiza autom√°ticamente. Si tu imagen no tiene campo circular/borde negro, pon Auto-c√≠rculo = OFF.",

        footerLine: "Ya no es un problema que tengas un ojo terrible calculando confluencias.",
        footerSub: "Confluencia hecha f√°cil.",
        footerMade: "hecho por Virginia Fern√°ndez con (mucha) ayuda de ChatGPT"
      },

      en: {
        hdrTitle: "CONFLUENCY ANALYSIS",
        hdrTagline: "Photo ‚Üí mask ‚Üí percentage. No drama.",

        startCam: "üì∑ Start camera (live)",
        stopCam: "‚õîÔ∏è Stop",
        snap: "üéØ Capture",

        hintCam: "If live camera doesn‚Äôt work (it can happen on iOS in ‚Äúhome screen‚Äù mode), use ‚ÄúTake photo‚Äù below.",
        btnPick: "üñºÔ∏è Choose file",
        btnPhoto: "üì∏ Take photo",

        lblConfluence: "Confluency",
        statusOpenCVLoading: "Loading OpenCV‚Ä¶",
        statusOpenCVReady: "OpenCV ready ‚úÖ Load an image and press \"Analyze confluency\".",
        statusOpenCVNever: "OpenCV didn‚Äôt load (try refresh / another network).",
        statusNeedImage: "Load an image or capture a photo.",
        statusCameraPerm: "Requesting camera permission‚Ä¶",
        statusCameraActive: "Camera active ‚úÖ Capture an image, then press \"Analyze confluency\".",
        statusCameraFail: "Couldn‚Äôt open the camera. Try ‚ÄúTake photo‚Äù.",
        statusCameraStopped: "Camera stopped.",
        statusCaptureDone: "Capture done ‚úÖ Adjust settings and press \"Analyze confluency\".",
        statusImageLoaded: "Image loaded ‚úÖ Adjust settings and press \"Analyze confluency\".",
        statusAnalyzing: "Analyzing‚Ä¶",
        statusDone: "Done ‚úÖ (if the mask doesn‚Äôt fit, tweak settings and analyze again)",
        statusError: "Error while analyzing (check console / try another photo).",

        lblMode: "Mode",
        optEdges: "Edges (fast)",
        optTexture: "Texture (more inclusive)",
        lblSens: "Sensitivity",
        lblFill: "Fill",
        lblAuto: "Auto-circle",

        analyzeBtn: "üî¨ Analyze confluency",
        analyzingBtn: "Analyzing‚Ä¶",
        downloadMaskBtn: "‚¨áÔ∏è Download mask",

        hintAnalyze: "Adjust settings and press <b>Analyze confluency</b>. It never runs automatically. If your image doesn‚Äôt have a circular field / black border, set Auto-circle = OFF.",

        footerLine: "No more suffering if you have a terrible eye for confluency.",
        footerSub: "Confluency made easy.",
        footerMade: "made with ChatGPT by Virginia Fern√°ndez"
      }
    };

    let lang = (localStorage.getItem("lang") || "es");
    let lastStatusKey = "statusOpenCVLoading";

    function t(key){ return (I18N[lang] && I18N[lang][key]) ? I18N[lang][key] : key; }

    function setLang(newLang){
      lang = newLang;
      localStorage.setItem("lang", lang);
      document.documentElement.lang = lang;

      // botones idioma
      document.getElementById("btnEN").classList.toggle("active", lang==="en");
      document.getElementById("btnES").classList.toggle("active", lang==="es");

      // textos
      document.getElementById("hdrTitle").textContent = t("hdrTitle");
      document.getElementById("hdrTagline").textContent = t("hdrTagline");

      document.getElementById("startCam").textContent = t("startCam");
      document.getElementById("stopCam").textContent = t("stopCam");
      document.getElementById("snap").textContent = t("snap");

      document.getElementById("hintCam").textContent = t("hintCam");
      document.getElementById("btnPick").textContent = t("btnPick");
      document.getElementById("btnPhoto").textContent = t("btnPhoto");

      document.getElementById("lblConfluence").textContent = t("lblConfluence");

      document.getElementById("lblMode").textContent = t("lblMode");
      document.getElementById("optEdges").textContent = t("optEdges");
      document.getElementById("optTexture").textContent = t("optTexture");

      document.getElementById("lblSens").textContent = t("lblSens");
      document.getElementById("lblFill").textContent = t("lblFill");
      document.getElementById("lblAuto").textContent = t("lblAuto");

      // botones principales (si no est√° analizando)
      if (!isAnalyzing) analyzeBtn.textContent = t("analyzeBtn");
      downloadMaskBtn.textContent = t("downloadMaskBtn");

      // hint con HTML
      document.getElementById("hintAnalyze").innerHTML = t("hintAnalyze");

      document.getElementById("footerLine").textContent = t("footerLine");
      document.getElementById("footerSub").textContent = t("footerSub");
      document.getElementById("footerMade").textContent = t("footerMade");

      // status actual
      setStatusKey(lastStatusKey);
    }

    function setStatusKey(key){
      lastStatusKey = key;
      statusEl.textContent = t(key);
    }

    // ---------- app ----------
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const pctEl = document.getElementById('pct');
    const statusEl = document.getElementById('status');

    const startCamBtn = document.getElementById('startCam');
    const stopCamBtn = document.getElementById('stopCam');
    const snapBtn = document.getElementById('snap');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const downloadMaskBtn = document.getElementById('downloadMaskBtn');

    const filePick = document.getElementById('filePick');
    const fileCam = document.getElementById('fileCam');

    const sens = document.getElementById('sens');
    const fill = document.getElementById('fill');
    const sensVal = document.getElementById('sensVal');
    const fillVal = document.getElementById('fillVal');
    const mode = document.getElementById('mode');
    const autoCircle = document.getElementById('autoCircle');

    // Quesito
    const progressWrap = document.getElementById('progressWrap');
    const progressText = document.getElementById('progressText');
    const indicator = document.querySelector('.donut circle.indicator');
    const R = 16;
    const CIRC = 2 * Math.PI * R;
    indicator.style.strokeDasharray = `${CIRC} ${CIRC}`;
    indicator.style.strokeDashoffset = `${CIRC}`;

    let stream = null;
    let cvReady = false;
    let lastImage = null;       // ImageData
    let isAnalyzing = false;
    let lastMaskDataURL = null; // PNG para descargar

    function updateUI() {
      sensVal.textContent = sens.value;
      fillVal.textContent = fill.value;
    }

    function updateButtons() {
      analyzeBtn.disabled = !(cvReady && lastImage) || isAnalyzing;
      downloadMaskBtn.disabled = !lastMaskDataURL || isAnalyzing;
    }

    function showProgress(show) {
      progressWrap.classList.toggle('hidden', !show);
      progressWrap.setAttribute('aria-hidden', show ? 'false' : 'true');
    }

    function setProgress(pct) {
      const p = Math.max(0, Math.min(100, pct));
      const offset = CIRC - (p / 100) * CIRC;
      indicator.style.strokeDashoffset = `${offset}`;
      progressText.textContent = `${Math.round(p)}%`;
    }

    function nextFrame() {
      return new Promise(resolve => requestAnimationFrame(() => resolve()));
    }

    // OpenCV init (nunca analiza autom√°ticamente)
    let hooked = false;
    const cvWait = setInterval(() => {
      if (typeof cv !== 'undefined') {
        if (!hooked) {
          hooked = true;
          cv['onRuntimeInitialized'] = () => {
            cvReady = true;
            setStatusKey("statusOpenCVReady");
            updateButtons();
          };
        }
        if (cv.Mat) {
          cvReady = true;
          setStatusKey("statusOpenCVReady");
          updateButtons();
          clearInterval(cvWait);
        }
      }
    }, 50);

    setTimeout(() => {
      if (!cvReady) setStatusKey("statusOpenCVNever");
    }, 12000);

    async function startCamera() {
      try {
        setStatusKey("statusCameraPerm");
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        snapBtn.disabled = false;
        stopCamBtn.disabled = false;
        setStatusKey("statusCameraActive");
      } catch (e) {
        console.error(e);
        setStatusKey("statusCameraFail");
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      video.srcObject = null;
      snapBtn.disabled = true;
      stopCamBtn.disabled = true;
      setStatusKey("statusCameraStopped");
    }

    function drawToCanvasFromVideo() {
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return;
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(video, 0, 0, w, h);
      lastImage = ctx.getImageData(0, 0, w, h);
    }

    function drawToCanvasFromImage(img) {
      const w = img.width;
      const h = img.height;
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0, w, h);
      lastImage = ctx.getImageData(0, 0, w, h);
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    function buildMaskPNG(maskMat8U) {
      const w = maskMat8U.cols;
      const h = maskMat8U.rows;
      const off = document.createElement('canvas');
      off.width = w;
      off.height = h;
      const ctx = off.getContext('2d');

      const img = ctx.createImageData(w, h);
      const dst = img.data;
      const src = maskMat8U.data;

      for (let i = 0, p = 0; i < src.length; i++, p += 4) {
        if (src[i]) {
          dst[p] = 255; dst[p+1] = 0; dst[p+2] = 0; dst[p+3] = 180;
        } else {
          dst[p] = 0; dst[p+1] = 0; dst[p+2] = 0; dst[p+3] = 0;
        }
      }

      ctx.putImageData(img, 0, 0);
      return off.toDataURL('image/png');
    }

    function downloadDataURL(dataURL, filename) {
      const a = document.createElement('a');
      a.href = dataURL;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    async function analyze() {
      if (!cvReady) { setStatusKey("statusOpenCVLoading"); return; }
      if (!lastImage) { setStatusKey("statusNeedImage"); return; }
      if (isAnalyzing) return;

      lastMaskDataURL = null;
      isAnalyzing = true;
      analyzeBtn.textContent = t("analyzingBtn");
      updateButtons();

      showProgress(true);
      setProgress(0);
      setStatusKey("statusAnalyzing");
      await nextFrame();

      try {
        const sens01 = parseInt(sens.value, 10) / 100;
        const fillPx = parseInt(fill.value, 10);
        const useAutoCircle = (autoCircle.value === 'on');
        const whichMode = mode.value;

        setProgress(8);  await nextFrame();

        const MAX_SIDE = 1100;
        let src = cv.matFromImageData(lastImage); // RGBA
        const w0 = src.cols, h0 = src.rows;
        const scale = Math.min(1, MAX_SIDE / Math.max(w0, h0));
        if (scale < 1) {
          let resized = new cv.Mat();
          cv.resize(src, resized, new cv.Size(Math.round(w0*scale), Math.round(h0*scale)), 0, 0, cv.INTER_AREA);
          src.delete();
          src = resized;
        }

        setProgress(20); await nextFrame();

        let gray = new cv.Mat();
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

        setProgress(30); await nextFrame();

        // ROI
        let fieldMask;
        if (useAutoCircle) {
          fieldMask = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8U);

          let cx = Math.floor(gray.cols/2), cy = Math.floor(gray.rows/2);
          let radius = Math.floor(Math.min(gray.cols, gray.rows)*0.48);

          let blur = new cv.Mat();
          cv.medianBlur(gray, blur, 5);

          let circles = new cv.Mat();
          cv.HoughCircles(
            blur, circles, cv.HOUGH_GRADIENT,
            1,
            gray.rows/4,
            120,
            25,
            Math.floor(Math.min(gray.cols, gray.rows)*0.30),
            Math.floor(Math.min(gray.cols, gray.rows)*0.52)
          );

          if (circles.cols > 0) {
            let best = 0;
            for (let i=0; i<circles.cols; i++) {
              const r = circles.data32F[i*3+2];
              if (r > circles.data32F[best*3+2]) best = i;
            }
            cx = Math.round(circles.data32F[best*3]);
            cy = Math.round(circles.data32F[best*3+1]);
            radius = Math.round(circles.data32F[best*3+2] * 0.98);
          }

          blur.delete(); circles.delete();
          cv.circle(fieldMask, new cv.Point(cx, cy), radius, new cv.Scalar(255), -1);
        } else {
          fieldMask = new cv.Mat(gray.rows, gray.cols, cv.CV_8U, new cv.Scalar(255));
        }

        setProgress(45); await nextFrame();

        // Segmentaci√≥n
        let cellMask = new cv.Mat.zeros(gray.rows, gray.cols, cv.CV_8U);

        if (whichMode === 'edges') {
          let blur2 = new cv.Mat();
          cv.GaussianBlur(gray, blur2, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

          let edges = new cv.Mat();
          const t1 = clamp(20 + (1 - sens01) * 60, 10, 90);
          const t2 = clamp(t1 * 2.5, 40, 220);
          cv.Canny(blur2, edges, t1, t2);

          edges.copyTo(cellMask);
          blur2.delete(); edges.delete();
        } else {
          let blur2 = new cv.Mat();
          cv.GaussianBlur(gray, blur2, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

          let lap16 = new cv.Mat();
          cv.Laplacian(blur2, lap16, cv.CV_16S, 3, 1, 0, cv.BORDER_DEFAULT);

          let abs8 = new cv.Mat();
          cv.convertScaleAbs(lap16, abs8);

          const thr = clamp(10 + (1 - sens01) * 40, 5, 60);
          cv.threshold(abs8, cellMask, thr, 255, cv.THRESH_BINARY);

          blur2.delete(); lap16.delete(); abs8.delete();
        }

        setProgress(70); await nextFrame();

        if (fillPx > 0) {
          const k = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(fillPx*2+1, fillPx*2+1));
          cv.morphologyEx(cellMask, cellMask, cv.MORPH_CLOSE, k);
          cv.dilate(cellMask, cellMask, k);
          k.delete();
        }

        setProgress(82); await nextFrame();

        let cellInField = new cv.Mat();
        cv.bitwise_and(cellMask, fieldMask, cellInField);

        // Confluencia
        const fieldCount = cv.countNonZero(fieldMask);
        const cellCount  = cv.countNonZero(cellInField);
        const confluence = (fieldCount > 0) ? (100.0 * cellCount / fieldCount) : 0;
        pctEl.textContent = confluence.toFixed(1) + '%';

        setProgress(90); await nextFrame();

        // Overlay
        let overlay = src.clone();
        let red = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(255, 0, 0, 90));
        let redMasked = new cv.Mat.zeros(src.rows, src.cols, src.type());
        red.copyTo(redMasked, cellInField);
        cv.addWeighted(overlay, 1.0, redMasked, 1.0, 0.0, overlay);

        if (useAutoCircle) {
          let outside = new cv.Mat();
          cv.bitwise_not(fieldMask, outside);
          let dim = new cv.Mat(src.rows, src.cols, src.type(), new cv.Scalar(0,0,0,140));
          let dimMasked = new cv.Mat.zeros(src.rows, src.cols, src.type());
          dim.copyTo(dimMasked, outside);
          cv.addWeighted(overlay, 1.0, dimMasked, 1.0, 0.0, overlay);
          outside.delete(); dim.delete(); dimMasked.delete();
        }

        cv.imshow(canvas, overlay);

        // Mascara descargable
        lastMaskDataURL = buildMaskPNG(cellInField);

        setProgress(100); await nextFrame();

        // Limpieza
        src.delete(); gray.delete(); fieldMask.delete();
        cellMask.delete(); cellInField.delete();
        overlay.delete(); red.delete(); redMasked.delete();

        setStatusKey("statusDone");
        setTimeout(() => { showProgress(false); }, 700);

      } catch (e) {
        console.error(e);
        setStatusKey("statusError");
        showProgress(false);
        lastMaskDataURL = null;
      } finally {
        isAnalyzing = false;
        analyzeBtn.textContent = t("analyzeBtn");
        updateButtons();
      }
    }

    // Eventos (NUNCA an√°lisis autom√°tico)
    startCamBtn.addEventListener('click', startCamera);
    stopCamBtn.addEventListener('click', stopCamera);

    snapBtn.addEventListener('click', () => {
      drawToCanvasFromVideo();
      setStatusKey("statusCaptureDone");
      showProgress(false);
      setProgress(0);
      lastMaskDataURL = null;
      updateButtons();
    });

    analyzeBtn.addEventListener('click', () => analyze());

    downloadMaskBtn.addEventListener('click', () => {
      if (!lastMaskDataURL) return;
      const ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      const base = (lang === "en") ? `mask_${ts}.png` : `mascara_${ts}.png`;
      downloadDataURL(lastMaskDataURL, base);
    });

    function handleFile(file) {
      if (!file) return;
      const img = new Image();
      img.onload = () => {
        drawToCanvasFromImage(img);
        setStatusKey("statusImageLoaded");
        showProgress(false);
        setProgress(0);
        lastMaskDataURL = null;
        updateButtons();
      };
      img.src = URL.createObjectURL(file);
    }

    filePick.addEventListener('change', (e) => handleFile(e.target.files[0]));
    fileCam.addEventListener('change',  (e) => handleFile(e.target.files[0]));

    ;[sens, fill, mode, autoCircle].forEach(el => {
      el.addEventListener('input', () => { updateUI(); });
      el.addEventListener('change', () => { updateUI(); });
    });

    // Idiomas
    document.getElementById("btnEN").addEventListener("click", () => setLang("en"));
    document.getElementById("btnES").addEventListener("click", () => setLang("es"));

    // Init
    updateUI();
    setLang(lang);
    setStatusKey("statusOpenCVLoading");
    updateButtons();
    showProgress(false);
  </script>
</body>
</html>
